package org.scharp.sas7bdat;

import org.scharp.sas7bdat.Sas7bdatExporter.Sas7bdatUnix64bitVariables;

import static org.scharp.sas7bdat.WriteUtil.write2;
import static org.scharp.sas7bdat.WriteUtil.write4;
import static org.scharp.sas7bdat.WriteUtil.write8;

/**
 * A subheader that contains some additional information about the columns.
 * <p>
 * sas7bdat.pdf calls this "column list", but it really corresponds to something that's a superset of columns.
 */
class ColumnListSubheader extends Subheader {
    /**
     * No subheader can be larger than Short.MAX_VALUE, so we only have room for (Short.MAX_VALUE - 50) / 2 = 16358
     * columns in each one.  However, SAS never creates datasets with a size larger than 32740 bytes, which is 16345
     * columns.
     */
    private static final int MAX_COLUMNS_PER_SUBHEADER = 16345;

    /**
     * Number of bytes in each variable entry.
     */
    private static final int SIZE_OF_ENTRY = 2;

    private final static int FOOTER_PADDING = 12;

    private final static int OFFSET_OF_FIRST_COLUMN = 38;

    private final int totalVariables;
    private final int totalColumns;

    ColumnListSubheader(Sas7bdatUnix64bitVariables variables, int variablesOffset) {
        // Determine how many variables, starting at offset, this subheader will hold.
        assert variablesOffset < variables.totalVariables();
        int variablesRemaining = variables.totalVariables() - variablesOffset;
        int totalVariablesInSubheader = Math.min(variablesRemaining, MAX_COLUMNS_PER_SUBHEADER);

        totalVariables = totalVariablesInSubheader;

        // To make it easier match up with datasets created by sas,
        // we allow for adding extra columns so that at the size of
        // this subheader matches the size generated by SAS.
        //
        // The idea is for a programmer to manually change the 0 to some
        // other number to facilitate troubleshooting problems with sas7bdat generation.
        // Doing so can make this library create a sas7bdat with the same offsets/sizes
        // that sas would have generated, which can make seeing difference easier.
        //
        // Setting totalColumns to a number that is much larger than totalVariables
        // causes sas to crash when reading the sas7bdat.
        totalColumns = totalVariables + 0;
    }

    /**
     * Gets the number of variables that fit into this subheader.
     *
     * @return The number of variables
     */
    int totalVariablesInSubheader() {
        return totalVariables;
    }

    /**
     * The number of bytes of data in this subheader without signature or FOOTER_PADDING.
     *
     * @return The number of bytes of data in this subheader
     */
    private int sizeOfData() {
        return totalColumns * SIZE_OF_ENTRY + OFFSET_OF_FIRST_COLUMN - SIGNATURE_SIZE;
    }

    @Override
    int size() {
        return totalColumns * SIZE_OF_ENTRY + OFFSET_OF_FIRST_COLUMN + FOOTER_PADDING;
    }

    @Override
    void writeSubheader(byte[] page, int subheaderOffset) {
        write8(page, subheaderOffset, SIGNATURE_COLUMN_LIST); // signature

        write2(page, subheaderOffset + 8, (short) sizeOfData());
        write2(page, subheaderOffset + 10, (short) 0x7FC8); // unknown
        write4(page, subheaderOffset + 12, 0x00); // unknown

        write8(page, subheaderOffset + 16, totalColumns * 2 + 22); // length remaining in subheader??

        write2(page, subheaderOffset + 24, (short) totalVariables);
        write2(page, subheaderOffset + 26, (short) totalColumns); // length of list
        write2(page, subheaderOffset + 28, (short) 1); // unknown
        write2(page, subheaderOffset + 30, (short) totalVariables); // unknown

        write2(page, subheaderOffset + 32, (short) 0); // unknown
        write2(page, subheaderOffset + 34, (short) 0); // unknown
        write2(page, subheaderOffset + 36, (short) 0); // unknown

        // column list values
        //
        // The purpose of this is unknown, but the values range from
        // -totalColumns to totalColumns and the absolute value of each non-zero
        // value must be unique or else SAS will treat the SAS7BDAT as malformed.
        // Therefore, it seems to be an ordering of columns with an additional
        // flag of boolean information that is a sign.
        //
        // The 0 might be a kind of flag, applied to either the variable which precedes or follows it.
        //
        // I have confirmed that this has nothing to do with the order in which variables are
        // physically ordered in the data section.
        //
        int offsetFromSubheaderStart = OFFSET_OF_FIRST_COLUMN;
        for (int i = 0; i < totalColumns; i++) {
            final short value;
            if (i < totalVariables) {
                value = (short) (i + 1);
            } else {
                value = (short) 0;
            }
            write2(page, subheaderOffset + offsetFromSubheaderStart, value);

            offsetFromSubheaderStart += SIZE_OF_ENTRY;
        }

        // There is some padding at the end.
        write4(page, subheaderOffset + offsetFromSubheaderStart, 0);
        write8(page, subheaderOffset + offsetFromSubheaderStart + 4, 0);
    }

    @Override
    byte typeCode() {
        return SUBHEADER_TYPE_B;
    }

    @Override
    byte compressionCode() {
        return COMPRESSION_UNCOMPRESSED;
    }
}